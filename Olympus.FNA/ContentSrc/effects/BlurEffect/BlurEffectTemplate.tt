<#@ template hostspecific="true" language="C#" compilerOptions="/unsafe" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".gen.cs" #>
<#
/* This file is responsible for:
 * - BlurEffect{Radius:D2}.gen.fx (which then get compiled into .fxo files by efb.exe),
 * - BlurEffectTemplate.cs, which contains fields used by and accessible via BlurEffect matching the generated effects.
 */

const int MaxRadius = 32;
const int Step = 8;
const string NameFormat = "BlurEffect{0:D2}.gen";
#>
<#

// BlurEffect{Radius:D2}.gen.fx

#>
<#
for (int radius = Step; radius <= MaxRadius; radius += Step) {
    int kernelSize = radius * 2 + 1;
#>
// Autogenerated from BlurEffectTemplate.tt
// Radius: <#= radius #> / Kernel Size: <#= kernelSize #>
float4x4 Transform;
float4 Color;
float4 OffsetsWeights[<#= kernelSize #>];
float4 MinMax;


texture2D Tex0;
sampler Tex0Sampler = sampler_state {
    Texture = Tex0;
};


void GetVertex(
    inout float4 position : SV_Position,
    inout float2 texCoord : TEXCOORD0,
    inout float4 color    : COLOR0
) {
    position = mul(position, Transform);
}


float4 GetPixel(
    float2 texCoord : TEXCOORD0,
    float4 color : COLOR0
) : SV_Target0 {
    float4 c = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 offsetWeight;
    /* unrolled for 0 <= i < kernelSize */ {
<#  for (int i = 0; i < kernelSize; i++) { #>
        offsetWeight = OffsetsWeights[<#= i #>];
        c += tex2D(Tex0Sampler, clamp(texCoord + offsetWeight.xy, MinMax.xy, MinMax.zw)) * offsetWeight.z;
<#  } #>
    }
    return c * color * Color;
}


technique Main
{
    pass
    {
        Sampler[0] = Tex0Sampler;
        VertexShader = compile vs_3_0 GetVertex();
        PixelShader = compile ps_3_0 GetPixel();
    }
}

<#  File.WriteAllText(Path.Combine(Path.GetDirectoryName(Host.TemplateFile), string.Format(NameFormat, radius) + ".fx"), GenerationEnvironment.ToString()); 
    GenerationEnvironment.Remove(0, GenerationEnvironment.Length);
}
#>
<#

// BlurEffectTemplate.cs

#>
// Autogenerated from BlurEffectTemplate.tt
using System.Collections.Generic;
using Microsoft.Xna.Framework;

namespace OlympUI {
    public partial class BlurEffectCache {

        private static readonly Dictionary<int, string> Names = new() {
<#      for (int radius = Step; radius <= MaxRadius; radius += Step) {
#>
            { <#= radius #>, "<#= string.Format(NameFormat, radius) #>" },
<#      } #>
        };

        private static readonly object[] WarmupKeys = {
<#      for (int radius = Step; radius <= MaxRadius; radius += Step) {
#>
            <#= radius #>,
<#      } #>
        };

    }

    public partial class BlurEffect {

        public static readonly int MaxRadius = <#= MaxRadius #>;
        public static readonly int Step = <#= Step #>;
        public static readonly string NameFormat = "<#= NameFormat #>";

<#
        const int strengthDivs = 8;
        const int strengthMax = 3;
        const int strengthIndexMax = strengthMax * strengthDivs;
#>

        private const int PrebakedWeightsStrengthDivs = <#= strengthDivs #>;
        private const int PrebakedWeightsStrengthMax = <#= strengthMax #>;
        private const int PrebakedWeightsStrengthIndexMax = <#= strengthIndexMax #>;

        // Vector2[x][strength][radius], access via PrebakedWeights[radius][strength]
        private static readonly uint[][][] PrebakedWeights = new uint[][][] {
<#      for (int radius = 0; radius <= MaxRadius; radius++) {
            // For each radius, go through each strength.
            int kernelSize = radius * 2 + 1;
            float[] kernel = new float[kernelSize];
#>
            // radius: <#= radius #>
            new uint[][] {
<#          for (int strengthIndex = 0; strengthIndex <= strengthIndexMax; strengthIndex++) {
                // For each strength, generate kernels.
                float strength = strengthIndex / (float) strengthDivs;
                float sigma = radius / strength;
                float twoSigmaSquare = 2f * sigma * sigma;
                float sigmaRoot = (float) Math.Sqrt(twoSigmaSquare * Math.PI);
                float total = 0f;

                if (radius == 0 || strengthIndex == 0) {
                    kernel[radius] = 1f;
                    total = 1f;
                } else {
                    for (int i = 0; i < kernelSize; i++) {
                        float ri = i - radius;
                        float weight = (float) Math.Exp(-(ri * ri) / twoSigmaSquare) / sigmaRoot;
                        total += weight;
                        kernel[i] = weight;
                    }
                }
#>
                // strength: <#= strength #>f
                // new float[] { <# for (int i = 0; i < kernelSize; i++) { #>0f, 0f, <#= (kernel[i] / total).ToString("F4", CultureInfo.InvariantCulture) #>f, 0f, <# } #>},
                new uint[] { <# for (int i = 0; i < kernelSize; i++) { #>0U, 0U, 0x<#= SingleToUInt32Bits(kernel[i] / total).ToString("X8") #>U, 0U, <# } #>},
<#          } #>
            },
<#      } #>
        };

    }
}
<#+ // Sadly BitConverter.SingleToUInt32Bits is missing from T4?
unsafe uint SingleToUInt32Bits(float value) {
    return *((uint*) &value);
}#>
